#' DS Class
#'
#' The `DS` class manages both raw data and its associated metadata, facilitating streamlined data manipulation.
#'
#' @field data A tibble containing the dataset, with each column representing a different variable (e.g., age, gender, survey responses).
#' @field var_labels A named list mapping each variable's identifier to a descriptive label, enhancing readability in outputs and reports.
#' @field val_labels A named list for categorical variables, where each entry maps numeric codes to meaningful category labels (e.g., 1 = "Agree", 2 = "Disagree").
#'
#' @export
#' @noRd
DS = R6::R6Class("DS", list(
	data = tibble(),
	var_labels = list(),
	val_labels = list()
))



# read/write

# Reads an SPSS (.sav) file and loads the data and metadata into the DS object.
DS$set("public", "get_spss", function(filename) {
	start_time = Sys.time()
	on.exit(message(glue("Read spss: {elapsed_fmt(Sys.time() - start_time)} ({self$nrow} rows, {length(self$variables)} variables)")))

	df_raw = haven::read_spss(filename)

	self$data = df_raw |> modify(\(x) `attributes<-`(x, NULL))
	self$var_labels = df_raw |> map(\(x) attr(x, "label", exact = T)) |> compact()
	self$val_labels = df_raw |> map(\(x) attr(x, "labels", exact = T)) |> compact()
})

# Loads data and metadata from an RDS file into the DS object.
DS$set("public", "get_rds", function(filename) {
	save_data = readRDS(filename)

	self$data = save_data$data
	self$var_labels = save_data$var_labels
	self$val_labels = save_data$val_labels
})

# Initializes the DS object, optionally loading data from a specified file.
DS$set("public", "initialize", function(filename = NULL) {
	if (!is.null(filename)) {
		if (tools::file_ext(filename) == "") filename = paste0(filename, ".rds")

		if (!file.exists(filename)) stop("File does not exist: ", filename, call. = F)

		file_extension = tools::file_ext(filename) |> tolower()

		if (file_extension == "sav") {
			self$get_spss(filename)
		} else if (file_extension == "rds") {
			self$get_rds(filename)
		} else {
			stop("Unknown file format: ", file_extension, ". Only .rds and .sav formats are supported.", call. = F)
		}
	}
})

# Saves the current data and metadata of the DS object to an RDS file.
DS$set("public", "save", function(filename) {
	if (tools::file_ext(filename) == "") filename = paste0(filename, ".rds")

	save_data = list(var_labels = self$var_labels, val_labels = self$val_labels, data = self$data)
	saveRDS(save_data, file = filename)
})


# basic

# Active binding that returns the names of variables in the dataset.
DS$set("active", "variables", \() names(self$data))

# Active binding that returns the number of rows in the dataset.
DS$set("active", "nrow", \() nrow(self$data))


# selection

#' Returns a tidyselect matches() expression that selects variables with the given prefixes followed by _ and digits.
#' @export
base = function(...) matches(paste(sprintf("^%s_\\d+$", c(...)), collapse = "|"))

# Returns column names selected via tidyselect syntax.
DS$set("public", "names", \(...) self$data |> select(...) |> names())

# Selects variables of the form prefix_1, prefix_2, ..., using tidyselect pattern generated by base().
DS$set("public", "base_name", \(...) self$names(base(...)))



# types

#' @export
is_multiple = \(x) is.list(x) && all(vapply(x, is.numeric, logical(1)))

# Determines and returns the type of specified variables in the dataset.
DS$set("public", "var_type", function(...) {
	map_chr(self$names(...), \(var) {
		if (is.numeric(self$data[[var]]) && var %in% names(self$val_labels)) {
			"single"
		} else if (is_multiple(self$data[[var]])) {
			"multiple"
		} else if (is.numeric(self$data[[var]])) {
			"numeric"
		} else if (is.character(self$data[[var]])) {
			"text"
		} else {
			warning("Variable does not match any expected type: ", var, call. = F)
			NA_character_
		}
	})
})

# Checks if the specified variables are nominal (single or multiple categorical).
DS$set("public", "is_nominal", \(vars) self$var_type(vars) %in% c("single", "multiple"))




# Filters the dataset based on provided conditions.
DS$set("public", "filter", \(...) self$data = self$data |> filter(...))

# Cleans up metadata by removing labels for variables no longer in the dataset.
DS$set("public", "vacuum", function() {
	self$var_labels = self$var_labels[names(self$var_labels) %in% self$variables]
	self$val_labels = self$val_labels[names(self$val_labels) %in% self$variables]
})

# Retains only the specified variables in the dataset and associated metadata.
DS$set("public", "keep", function(...) {
	self$data = self$data |> select(...)
	self$vacuum()
})

# Removes the specified variables from the dataset and associated metadata.
DS$set("public", "remove", function(...) {
	self$data = self$data |> select(-c(...))
	self$vacuum()
})

# Changes the order of specified variables in the dataset.
DS$set("public", "move", function(..., after = NULL, before = NULL) {
	self$data = self$data |> relocate(..., .after = {{ after }}, .before = {{ before }})
})

# Creates a clone of the DS object with data filtered by specified conditions.
DS$set("public", "clone_if", function(...) {
	tds = self$clone()
	tds$filter(...)
	invisible(tds)
})





# Restructures the dataset by converting specified variable groups into individual cases.
DS$set("public", "vars_to_cases", function(index, ..., index_label = NULL, index_values = NULL, index_labels = NULL) {
	start_time = Sys.time()
	on.exit(cat("Restruct:", elapsed_fmt(Sys.time() - start_time), "\n"))

	cols_empty = \(df) Reduce(`&`, df |> map(var_empty))

	cols_list = c(...)
	all_cols = unlist(cols_list)

	if (length(unique(lengths(cols_list))) > 1) stop("All column groups must have the same length.", call. = F)
	if (!all(all_cols %in% self$variables)) {
		missing_vars = setdiff(all_cols, self$variables)
		stop(sprintf("Not all variables are present in the dataframe. Missing: %s", paste(missing_vars, collapse = ", ")), call. = F)
	}

	base_df = self$data |> select(-all_of(all_cols))

	if (is.null(index_values)) index_values = seq_along(cols_list[[1]])

	self$data = index_values |> imap(\(index_value, i) {
		group = map_chr(cols_list, i)
		group_df = self$data |> select(all_of(group))
		selected_cols = !cols_empty(group_df)
		base_df_slice = base_df[selected_cols, ]
		base_df_slice[[index]] = index_value
		bind_cols(base_df_slice, group_df[selected_cols, ])
	}) |> list_rbind()

	cols_list |> iwalk(\(cols, var_name) {
		self$set_val_labels({{ var_name }}, self$val_labels[[cols[1]]])
		self$set_var_label(var_name, self$var_labels[[cols[1]]])
	})

	if (is.null(index_labels)) index_labels = as.character(index_values)
	self$set_val_labels({{ index }}, setNames(index_values, index_labels))

	if (!is.null(index_label)) self$var_labels[[index]] = index_label

	self$vacuum()
})




# Converts multiple indicator variables into single multiple-response variables.
DS$set("public", "conv_multiples", function() {
	start_time = Sys.time()
	on.exit(cat("Convert multiples:", elapsed_fmt(Sys.time() - start_time), "\n"))

	sep = ": "

	mdset_data = tibble(var_name = self$variables) |>
		filter(grepl("_[0-9]+$", var_name)) |>
		filter(map_lgl(var_name, \(x) identical(self$val_labels[[x]], c("-" = 0, "+" = 1)))) |>
		mutate(label = self$get_var_labels(all_of(var_name))) |>
		filter(!is.na(label)) |>
		mutate(tokens = strsplit(label, sep, fixed = T)) |>
		filter(lengths(tokens) > 1) |>
		mutate(prefix = map_chr(tokens, \(x) x[1])) |>
		mutate(label = map_chr(tokens, \(x) paste(x[-1], collapse = sep))) |>
		select(-tokens) |>
		mutate(base_name = sub("_[0-9]+$", "", var_name)) |>
		mutate(id = sub(".*_([0-9]+)$", "\\1", var_name) |> as.numeric()) |>
		group_by(base_name) |>
		filter(n_distinct(prefix) == 1) |>
		ungroup() |>
		arrange(base_name, id)

	mdsets = mdset_data$base_name |> unique()

	for (mdset in mdsets) {
		current_slice = mdset_data[mdset_data$base_name == mdset, ]

		col_data = do.call(rbind, seq_len(nrow(current_slice)) |> lapply(\(i) {
			if_else(has(self$data[[current_slice$var_name[i]]], 1), current_slice$id[i], NA_real_)
		})) |> as.data.frame() |> as.list() |> lapply(\(x) x[!is.na(x)]) |> unname()

		self$data[[mdset]] = col_data
		self$data = self$data |> relocate(all_of(mdset), .before = current_slice$var_name[1])
		self$data[current_slice$var_name] = NULL

		self$var_labels[[mdset]] = current_slice$prefix[1]
		self$val_labels[[mdset]] = setNames(current_slice$id, current_slice$label)
	}

	self$vacuum()
})


# Provides a summary view of variables, including their names, labels, types, and value labels, optionally filtered by name or label.
DS$set("public", "var_view", function(name = NULL, label = NULL) {
	val_labels_format = function(xs) {
		if (is.null(xs)) return(NA_character_)
		paste(glue("[{xs}]"), chartr("\t\n", "  ", names(xs)), collapse = "; ")
	}

	res = tibble(
		pos = seq_along(self$variables),
		variable = self$variables,
		label = self$get_var_labels(everything())
	)

	if (!is.null(name)) {
		if (is.numeric(name)) {
			res = res |> slice(name)
		} else {
			res = res |> filter(grepl(name, variable))
		}
	}

	if (!is.null(label)) {
		res = res |> filter(grepl(.env$label, .data$label))
	}

	res = res |> mutate(
		type = self$var_type(all_of(variable)),
		type = ifelse(is.na(type), "type error", type),
		type = ifelse(type == "single", NA_character_, type),
		val_labels = variable |> map_chr(\(var_name) val_labels_format(self$val_labels[[var_name]]))
	) |> select(pos, variable, type, label, everything())

	res
})



# Checks variables for properties like uniqueness, emptiness, and validity based on specified criteria.
DS$set("public", "var_check", function(name = NULL, label = NULL) {
	res = self$var_view(name, label)

	res = res |> mutate(
		unique_values = variable |> map(\(var) self$data[[var]] |> unlist() |> unique() |> discard(\(x) is.na(x) || x == "")),
		empty = ifelse(lengths(unique_values) == 0, "1", ""),
		same = ifelse(lengths(unique_values) == 1, "1", ""),
		valid = variable |> map_dbl(\(var) self$data[[var]] |> map(\(x) if (all(is.na(x)) || all(x == "")) NULL else x) |> compact() |> length()),
		distinct = lengths(unique_values),
		unique_values = NULL
	)

	res
})




# Exports a copy of the dataset, optionally selecting specific variables and formatting value labels for readability.
DS$set("public", "export_copy", function(...) {
	df = if (length(enquos(...)) == 0) self$data else self$data |> select(...)

	mvars = names(df) |> discard(\(x) is.character(df[[x]]) || (!(x %in% names(self$val_labels)) && !is_multiple(df[[x]])))

	df = df |> mutate(across(all_of(mvars), \(var) {
		values = self$prepare_val_labels(cur_column())
		labels = sprintf("[%s] %s", values, chartr("\t\n", "  ", names(values)))

		if (is_multiple(var)) {
			var |> map_chr(\(x) paste0(labels[match(x, values)], collapse = "; "))
		} else {
			labels[match(var, values)]
		}
	}))

	setNames(df, names(df) |> modify_if(\(x) x %in% names(self$var_labels), \(x) paste(x, self$var_labels[[x]], sep = "|")))
})



